[{"title":"软件设计原则","date":"2019-08-27T12:28:44.000Z","path":"2019/08/27/软件设计原则/","text":"软件设计原则为了达到代码的复用、可维护性的目的，软件设计需遵循软件设计原则。 单一职责原则（Single Responsibility Principle）一个类只承担一个职责，不同的类具备不同的职责，各司其职。这样可以降低类的复杂性，实现什么职责都有清晰明确的定义；提高了代码可读性和可维护性；降低了变更代码引起的风险。 里式替换原则（Liskov Substitution Principle）子类可以扩展父类的方法，但是不应该复写父类的方法。定义为：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it。即一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序出错。这样便要求子类必须完全实现父类的方法；覆盖或实现父类的方法时输入参数可以被放大，输出结果可以被缩小（逆变协变）。采用里式替换原则可以提高程序的健壮性，版本升级时也可以保持非常好的兼容性。 依赖倒置原则（Dependence Inversion Principle）面向接口编程，提取事物的本质和共性。模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；接口或者抽象类不依赖于实现类；实现类依赖于接口或抽象类。每个类尽量都有接口或抽象类；变量的表面类型尽量是接口或者抽象类；任何类都不应该从具体类派生，尽量不要复写基类的方法。采用依赖倒置原则可减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码可读性和可维护性。依赖也可以称为注入，一般可以通过构造函数注入，属性注入，接口注入。 接口隔离原则（Interface Segregation Principle）建立单一接口，尽量细化接口，接口中的方法尽量少。一个接口只服务于一个子模块或者业务逻辑；通过业务逻辑尽量压缩接口中的方法；可以提高内聚，降低耦合，提高系统的灵活性和可维护性。 迪米特原则（Law of Demeter）也称为最少知识原则，一个对象应该对其他对象保持最少的了解，实现低耦合、高内聚。如果一个对象对另一个对象了解得越多，那么，它们之间的耦合性也就越强，当修改其中一个对象时，对另一个对象造成的影响也就越大。 开闭原则（Open Closed Principle）Software entities like classes, modules and functions should be open for extension but closed for modifications。类、模块、函数，可以去扩展，但不要去修改，即尽量通过扩展实体行为来实现变化。需要抽象约束，将相同的变化封装到一个接口或抽象类，将不同的变化封装到不同的接口或抽象类中。 组合/聚合复用原则（Composite/Aggregate Reuse Principle)尽量使用组合/聚合，尽量不要使用继承。组合/聚合复用原则是在一个新的对象里面使用依稀已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。 继承复用有缺点：如果基类发生了改变，那么派生类的实现不得不发生改变；而且从超类继承而来的实现是静态的，不可能在运行时发生改变，因此它的灵活性差并最终会限制复用性。"},{"title":"背包问题","date":"2019-08-26T11:12:42.000Z","path":"2019/08/26/背包问题/","text":"题目来源： acwing 题目内容有N件物品和一个容量是V的背包。每件物品只能使用一次。 第i件物品的体积是vi，价值是wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有N行，每行两个整数vi，wi，用空格隔开，分别表示第i件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0 &lt; N，V ≤ 1000 0 &lt; vi，wi ≤ 1000 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 8 代码实现12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int f[N];int V[N], W[N];int main() &#123; int n, v; cin &gt;&gt; n &gt;&gt; v; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; V[i] &gt;&gt; W[i]; &#125; // i 表示第i个物体，j表示体积，f[j]表示在体积为j时所能装下的最大价值 for(int i = 1; i &lt;= n; i++) &#123; for(int j = v; j &gt;= V[i]; j--) &#123; f[j] = max(f[j - V[i]] + W[i], f[j]); &#125; &#125; cout &lt;&lt; f[v] &lt;&lt; endl; return 0;&#125;"},{"title":"位运算应用","date":"2019-08-26T01:49:13.000Z","path":"2019/08/26/位运算应用/","text":"快速幂求解来源：acwing 89 题目内容求a的b次方对p取模的值。 输入格式 三个整数a，b，p，在同一行用空格隔开。 输出格式 输出一个整数，表示a ^ b mod p 的值。 数据范围 0 ≤ a, b, p ≤ 109 输入样例： 3 2 7 输出样例： 2 代码实现12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b, p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; // 处理p为1时的情况，故%p int res = 1 % p; while(b) &#123; if(b &amp; 1) &#123; res = res * 1ll * a % p; &#125; a = a * 1ll * a % p; b &gt;&gt;= 1; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 64位整数乘法来源： acwing 90 题目内容求a乘b对*p取模的值。 输入格式 第一行输入整数a，第二行输入整数b，第三行输入整数p。 输出格式 输出一个整数，表示a * b mod p的值。 数据范围 1 ≤ a，b，p ≤ 10 18 输入样例： 3 4 5 输出样例： 2 实现代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;int main() &#123; ULL a, b, p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; ULL result = 0; while(b) &#123; if(b &amp; 1) &#123; result = (result + a) % p; &#125; a = (a &lt;&lt; 1) % p; b &gt;&gt;= 1; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;"},{"title":"ios 集成 OpenCV","date":"2019-08-15T02:17:16.000Z","path":"2019/08/15/ios-集成-OpenCV/","text":"IOS 集成 OpenCV 上OpenCV官网下载你所需要版本的opencv.framework库 将opencv.framework拖拉入项目文件夹。 在项目设置处，在General -&gt; Linked Frameworks and Libraries 导入下面这些库： 最后，将使用OpenCV的文件后缀从.m改为.mm"},{"title":"First","date":"2019-07-23T11:06:10.223Z","path":"2019/07/23/At-First/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New blog\" More info: Writing Run server1$ hexo server More info: Server or 1$ hexo s 有时候可能会遇到端口被占用，可列出端口4000的进程： 1$ netstat -ano|findstr 4000 然后关闭该进程（6972为进程ID）： 1$ taskkill /pid 6972 /f Generate static files1$ hexo generate More info: Generating or 1$ hexo g Deploy to remote sites1$ hexo deploy More info: Deployment or 1$ hexo d 此时若报如下错误： ERROR Deployer not found: git 可执行如下命令： 1npm install --save hexo-deployer-git"}]