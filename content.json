[{"title":"数组处理","date":"2019-08-29T02:12:06.000Z","path":"2019/08/29/数组处理/","text":"数组处理找出数组中重复的数字题目来源： acwing 13 题目给定一个长度为n的整数数组nums，数组中所有的数字都在0 ~ n - 1的范围内。 数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。 请找出数组中任意一个重复的数字。 注意： 如果某些数字不在0 ~ n - 1的范围内，或数组中不包含重复数字，则返回-1； 样例 给定 nums = [2, 3, 5, 4, 2, 6, 7]。 返回 2 或 3。 代码实现 11234567891011121314151617181920class Solution &#123;public: int duplicateInArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); bool *tags = new bool[n]; memset(tags, false, sizeof(bool) * n); for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &lt; 0) return -1; &#125; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &lt; 0) return -1; if(tags[nums[i]]) &#123; return nums[i]; &#125; else &#123; tags[nums[i]] = true; &#125; &#125; return -1; &#125;&#125;; 代码实现21234567891011121314151617181920class Solution &#123;public: int duplicateInArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(auto x : nums) &#123; if(x &lt; 0 || x &gt;= n) &#123; return -1; &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; while(i != nums[i] &amp;&amp; nums[nums[i]] != nums[i]) &#123; swap(nums[i], nums[nums[i]]); &#125; if(i != nums[i] &amp;&amp; nums[i] == nums[nums[i]]) &#123; return nums[i]; &#125; &#125; return -1; &#125;&#125;; 不修改数组找出重复的数字题目来源： acwing 14 题目给定一个长度为n + 1 的数组nums，数组中所有的数均在1~n的范围内，其中n ≥ 1. 请找出数组中任意一个重复的数，但不能修改输入的数组。 样例 给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。 返回2 或 3。 思考题： 如果只能使用O(1)的额外空间，该怎么做呢？ 代码实现12345678910111213141516171819class Solution &#123;public: int duplicateInArray(vector&lt;int&gt;&amp; nums) &#123; int l = 1, r = nums.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; int count = 0; for(auto x : nums) &#123; count += x &gt;= l &amp;&amp; x &lt;= mid; &#125; if(count &gt; mid - l + 1) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l; &#125;&#125;;"},{"title":"设计模式","date":"2019-08-28T05:40:09.000Z","path":"2019/08/28/设计模式/","text":"基础设计模式定义设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。设计模式是实现特定需求的接近代码层面的设计套路，通常用于梳理和表达对象之间较为复杂的依赖和交互关系，将错综复杂的容易膨胀的难以理解和扩展的条件判断逻辑解开成一系列对象的清晰可理解的易扩展的交互结构。 使用目的为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式使软件工程的基石脉络。 设计模式是软件设计的入门指南，其主要理念是：面向接口的编程，组合与委托优先于基础。理解设计模式的关键点：关注点及目标用途、协作对象、静态结构及动态交互。 常用基本设计模式工厂模式（FactoryMethod） 根据不同条件为客户端创建实现相同接口和功能的实例，而客户端使用的是统一的功能接口。 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。 使用场景： 当一个类不知道它所必须创建的对象的类的时候 当一个类希望由它的子类来指定它所创建的对象的时候 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 单例模式（Singleton） 保证一个类仅有一个实例，并提供一个访问它的全局访问点。该类需要跟踪单一的实例，并确保没有其他实例比创建。单例类适合于需要通过单个对象访问全局资源的场合。 生成器模式（Builder） 复杂对象的创建，需要多个步骤或组合多个子部件完成，并且在这些步骤或组件完成之前，不允许该实例的生成。通常会私有化构造器，在构造的每一步骤中会设置某些属性并返回其自身，便于链式调用，提供一个build方法生成满足某种实例创建契约的最终实例。 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 使用场景： 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构建的对象有不同的表示时。 抽象工厂模式（AbstractFactory） 系统含有多个相互协作的不同功能和特性的组件，每个组件可定制为不同的种类和风格。抽象工厂为每个组件的创建提供相对应的抽象工厂的创建接口，而由具体的工厂实现对应的组件创建接口。 提供一个接口，用于创建与某些对象相关或依赖于某些对象的类家族，而又不需要指定它们的具体类。通过这种模式可以去除客户代码和来自工厂的具体对象细节之间的耦合关系。 类簇是一种把一个公共的抽象超类下的一些私有的具体子类组合在一起的架构。抽象超类负责声明创建私有子类实例的方法，会根据被调用方法的不同分配恰当的具体子类，每个返回的对象都可能属于不同的私有子类。 原型模式（Prototype） 从现有对象实例快速生成和定制化对象实例，而不需要创建大量子类。原型模式特别适合于定制化。 比如，现有一个房间对象，要创建含有炸弹的房间对象；这些房间对象的房间属性都是一样的，而这些炸弹可能是不同种类，也可能是相同种类只是颜色不同，使用普通的继承结构和初始化操作会产生大量的相同的赋值代码。此时使用原型模式非常恰当。通过一个含有普通炸弹的房间对象作为原型进行克隆，然后设置炸弹的种类和属性即可。 原型模式使用有两点：需要一个原型管理器进行原型注册和查找；根据场景正确地实现浅拷贝和深拷贝。 为原型静态或动态地增加属性和行为，可以轻易地为所有从该原型衍生的对象添加属性和行为。 适配器模式（Adapter） 将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 复用现有类或对象的功能，实现客户端需要的接口。有类适配器和对象适配器两种。类适配器继承现有类，可以重新定义部分行为；对象适配器使用现有类的对象实例并委托实现给该对象，可灵活使用多个现有对象。通常使用对象适配器。 组合模式（Composite） 具有层次性结构的单个对象与组合对象具有一致的接，客户端能够使用同一的接口操作局部和整体。组合模式最大的优点是他的节点可以自由增加，且调用节点方便。 外观模式（Facade） 为复杂子系统提供简单易用的接口，屏蔽实现的复杂性。通过减少复杂度和隐藏子系统之间的通讯和依赖性，使子系统更加易于使用。 装饰器模式（Decorator) 具有相同接口的对象可以在运行时动态组合成具有复合行为的对象。可以在运行时为现有对象动态添加任意复杂的额外行为。 这种模式动态地将额外的责任附加到一个对象上。在进行功能扩展时，装饰是子类化之外的一种灵活的备选方法。和子类化一样，采纳装饰模式可以加入新的行为，而又不必修改已有的代码。装饰将需要扩展的类的对象进行包装，实现与该对象相同的接口，并在将任务传递给被包装对象之前或之后加入自己的行为。装饰模式表达了这样的设计原则：类应该接纳扩展，但避免修改。 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。 代理模式（Proxy） 为对象或服务提供间接访问机制。提供间接访问的原因可能有：隐藏源对象或源服务的部署细节（远程代理）；源对象创建开销很大，只有需要的时候才创建（虚代理）；访问源对象需要某种权限或同步互斥（保护代理）；需要为访问源对象和源服务增加额外的行为（智能代理）。代理对象与源对象通常有一致的接口，并持有源对象的引用。 涉及的角色： 协议：定义代理和委托的共同接口（方法） 委托：根据指定的协议，委托代理去完成实现指定接口（方法） 代理：根据指定的协议，实现委托需要实现的接口（方法） 桥接模式（Bridge） 抽象部分与实现部分各具有独立的继承层次结构分开变化发展，使用桥接器将抽象继承层次与实现继承层次连接起来，实现并不直接继承抽象类，而是抽象类持有实现类的引用。 通常适用于这样的场景：创建一个标准协议的接口框架，而接口框架的实现可以有多种选择，客户端可以根据需要选择不同的实现。 桥接器通常与抽象工厂模式、单例模式组合使用。 享元模式（Flyweight） 运用共享技术有效地支持大量细粒度的对象。 可使用缓存技术实现。为了尽可能节省内存开销，需要识别享元对象中的外部状态并从中移除，使得享元对象的共享达到最大化。 适用场景： 一个应用程序适用了大量的对象。 完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。 模板方法模式（TemplateMethod） 预先定义处理流程，对于流程中某些环节的具体处理留给具体业务去完成。模板方法模式应指明哪些是钩子操作（可选重定义，有默认实现），哪些是抽象操作（必须重定义，没有默认实现）。 这种模式为某个操作中的算法定义框架，并将算法中的某些步骤推迟到子类实现。模板方法模式使子类可以重定义一个算法中的特定步骤，而不需要改变算法的结构。 策略模式（Strategy） 为特定任务提供多种实现算法，并在不同场景下可灵活切换而对客户端透明。比如批量拉取数据的顺序策略以及并发策略。使用策略模式时，客户端可持有策略实现对象的接口或者策略实现对象的模板接口参数。 观察者模式（Observer） 每个对象都有一系列观察者，当对象发生更新时推送更新给观察者，由观察者决定具体行为。通常引申为订阅-消费模式。 这种模式定义一种对象间一对多的依赖关系，使得当一个对象的状态发生变化时，其他具有依赖关系的对象可以自动地被通知和更新。主体和观察者具有宽松的耦合关系。观察和被观察对象之间可以进行通讯，而不需要太多地了解对方。 职责链模式（ResponsibilityChain） 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 将能够处理某种请求的多个对象串联成一条处理链，请求沿着处理链传递给这些对象，对请求的发送者隐藏处理请求的实现细节（请求的发送者不需要知道谁真正处理这个请求）。责任链上的请求处理对象可以在运行时动态增减。责任链的实现中，链的构造和请求的传递既可以使用全局控制器来配置、生成和控制（集中式策略），也可以通过链上的对象来负责引用和传递（分散式策略）。需要构造两种接口：请求接口和请求处理对象的接口，而请求处理对象则需要实现请求接口。请求处理对象的顺序也值得斟酌，通常是从特殊到普遍的顺序。异常捕获和处理机制即是职责链模式的具体应用例子之一。 命令模式（Command） 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。请求对象将一或多个动作绑定在特定的接收者上。命令模式将发出请求的对象和接收及执行请求的对象区分开来。 迭代器模式（Iterator） 提供了一种顺序访问聚合对象（也就是一个集合）中的元素，而又不必暴露潜在表示的方法。迭代器模式将访问和遍历集合元素的责任从集合对象转移到迭代器对象。迭代器定义一个访问集合元素的接口，并对当前元素进行跟踪。不同的迭代器可以执行不同的遍历策略。 状态模式（State） 一个对象具有多种状态，其某种复杂行为取决于状态及状态变迁。此时，可以单独将状态及行为抽离出来建模，并将对象的行为委托状态对象完成。若状态行为比较简单，可以使用具有行为的枚举或表来实现；若状态行为比较复杂，则需要使用状态抽象类及具体状态子类来实现。状态对象可持有对象的引用，便于访问所需要的信息。状态子类没有实例属性，可以实现为单例类。 中介者模式（Mediator） 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 有多个基础服务方，多个业务方；每个业务方都有自己需要定制化的东西。如果所有业务方直接与各个基础服务方打交道，会导致”服务方-业务方”的依赖关系激增，交互也变得复杂。引入中介者对象作为服务方和业务方的调度调控，每个基础服务方和业务方只需要与中介者交互，而不需要知道具体的服务方和业务方。中介者对象将交互行为集中化，简化了依赖关系数量。 解释器模式（Interpret） 如果特定问题可以使用一种简单的语言来描述，那么可以定义一种文法，以及对应的解释器。将问题的求解归结为根据文法构造句子，然后使用解释器来解释句子生成结果。适用于领域语言设计和实现。 访问模式（Visitor） 一个复杂的复合对象含有多个子对象，对于每个子对象都需要定义操作，而每个子对象的操作都可能不一样。全部操作的定义放在这个复合对象里，将使得这个复合对象异常的庞大臃肿。使用访问器模式，可以将这些操作抽离出来。每种操作都是一个访问器，可以定义访问器接口；每个子对象以及该复合对象都有一个accept方法。复合对象的accept实现将委托给遍历子对象的accept。Visitor主要用于为复合对象定义可扩展的新操作。当定义一个新操作时，只需要增加一个新的Visitor，而不需要改变现有的其他类。 备忘录模式（Memento） 历史状态存储、撤销与回退。 这种模式在不破坏封装的情况下，捕捉和外部化对象的内部状态，使对象在之后可以恢复到该状态。备忘录模式使关键对象的重要状态外部化，同时保持对象的内聚性。"},{"title":"我的CSDN博客杂烩","date":"2019-08-27T13:28:49.000Z","path":"2019/08/27/我的CSDN博客杂烩/","text":"之前一直都在CSDN上写博客，现在做个整理，方便以后查找。 Unity3D学习笔记Unity3D课程 第一次作业 Unity3D 实践学习1 GUI井字棋的实现 C#学习笔记——List C#学习笔记——HashTable Unity3D学习笔记——第二次作业 Unity3D 小实验：太阳系模拟 Unity3D 小项目：牧师与恶魔小游戏 参考Fantasy Skybox FREE 构建自己的游戏场景 牧师与恶魔小游戏 动作分离版 Unity3D 巡逻兵 Unity3D 粒子光环制作 牧师与恶魔过河游戏——智能提示 Unet联网小游戏——简易版坦克动荡 系统分析与设计作业系统分析与设计（1） 系统分析与设计（2） 系统分析与设计（3） 系统分析与设计（4） 系统分析与设计（5） 系统分析与设计（6） 其他MIPS求数组交集 实训大二 Java实现简易计算器 Python圆形场景转换 直方图均衡化的实现 Bresenham’s algorithm（布兰森汉姆算法）画直线 Halstead 复杂度简介"},{"title":"软件设计原则","date":"2019-08-27T12:28:44.000Z","path":"2019/08/27/软件设计原则/","text":"软件设计原则为了达到代码的复用、可维护性的目的，软件设计需遵循软件设计原则。 单一职责原则（Single Responsibility Principle） 一个类只承担一个职责，不同的类具备不同的职责，各司其职。这样可以降低类的复杂性，实现什么职责都有清晰明确的定义；提高了代码可读性和可维护性；降低了变更代码引起的风险。 里式替换原则（Liskov Substitution Principle） 子类可以扩展父类的方法，但是不应该复写父类的方法。定义为：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it。即一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序出错。这样便要求子类必须完全实现父类的方法；覆盖或实现父类的方法时输入参数可以被放大，输出结果可以被缩小（逆变协变）。采用里式替换原则可以提高程序的健壮性，版本升级时也可以保持非常好的兼容性。 依赖倒置原则（Dependence Inversion Principle） 面向接口编程，提取事物的本质和共性。模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；接口或者抽象类不依赖于实现类；实现类依赖于接口或抽象类。每个类尽量都有接口或抽象类；变量的表面类型尽量是接口或者抽象类；任何类都不应该从具体类派生，尽量不要复写基类的方法。采用依赖倒置原则可减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码可读性和可维护性。依赖也可以称为注入，一般可以通过构造函数注入，属性注入，接口注入。 接口隔离原则（Interface Segregation Principle） 建立单一接口，尽量细化接口，接口中的方法尽量少。一个接口只服务于一个子模块或者业务逻辑；通过业务逻辑尽量压缩接口中的方法；可以提高内聚，降低耦合，提高系统的灵活性和可维护性。 迪米特原则（Law of Demeter） 也称为最少知识原则，一个对象应该对其他对象保持最少的了解，实现低耦合、高内聚。如果一个对象对另一个对象了解得越多，那么，它们之间的耦合性也就越强，当修改其中一个对象时，对另一个对象造成的影响也就越大。 开闭原则（Open Closed Principle） Software entities like classes, modules and functions should be open for extension but closed for modifications。类、模块、函数，可以去扩展，但不要去修改，即尽量通过扩展实体行为来实现变化。需要抽象约束，将相同的变化封装到一个接口或抽象类，将不同的变化封装到不同的接口或抽象类中。 组合/聚合复用原则（Composite/Aggregate Reuse Principle) 尽量使用组合/聚合，尽量不要使用继承。组合/聚合复用原则是在一个新的对象里面使用依稀已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。 继承复用有缺点：如果基类发生了改变，那么派生类的实现不得不发生改变；而且从超类继承而来的实现是静态的，不可能在运行时发生改变，因此它的灵活性差并最终会限制复用性。"},{"title":"背包问题","date":"2019-08-26T11:12:42.000Z","path":"2019/08/26/背包问题/","text":"01背包问题来源： acwing 题目内容有N件物品和一个容量是V的背包。每件物品只能使用一次。 第i件物品的体积是vi，价值是wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有N行，每行两个整数vi，wi，用空格隔开，分别表示第i件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0 &lt; N，V ≤ 1000 0 &lt; vi，wi ≤ 1000 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 8 代码实现12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int f[N];int V[N], W[N];int main() &#123; int n, v; cin &gt;&gt; n &gt;&gt; v; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; V[i] &gt;&gt; W[i]; &#125; // i 表示第i个物体，j表示体积，f[j]表示在体积为j时所能装下的最大价值 for(int i = 1; i &lt;= n; i++) &#123; for(int j = v; j &gt;= V[i]; j--) &#123; f[j] = max(f[j - V[i]] + W[i], f[j]); &#125; &#125; cout &lt;&lt; f[v] &lt;&lt; endl; return 0;&#125; 完全背包问题来源： acwing 题目内容有N件物品和一个容量是V的背包。每种物品都有无限件可用。 第i件物品的体积是vi，价值是wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有N行，每行两个整数vi，wi，用空格隔开，分别表示第i件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0 &lt; N，V ≤ 1000 0 &lt; vi，wi ≤ 1000 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 10 代码实现123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int S = 1010;int f[S];int main() &#123; int N, V; cin &gt;&gt; N &gt;&gt; V; for(int i = 0; i &lt; N; i++) &#123; int v, w; cin &gt;&gt; v &gt;&gt; w; for(int j = v; j &lt;= V; j++) &#123; f[j] = max(f[j], f[j - v] + w); &#125; &#125; cout &lt;&lt; f[V] &lt;&lt; endl; return 0;&#125;"},{"title":"位运算应用","date":"2019-08-26T01:49:13.000Z","path":"2019/08/26/位运算应用/","text":"快速幂求解来源：acwing 89 题目内容求a的b次方对p取模的值。 输入格式 三个整数a，b，p，在同一行用空格隔开。 输出格式 输出一个整数，表示a ^ b mod p 的值。 数据范围 0 ≤ a, b, p ≤ 109 输入样例： 3 2 7 输出样例： 2 代码实现12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b, p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; // 处理p为1时的情况，故%p int res = 1 % p; while(b) &#123; if(b &amp; 1) &#123; res = res * 1ll * a % p; &#125; a = a * 1ll * a % p; b &gt;&gt;= 1; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 64位整数乘法来源： acwing 90 题目内容求a乘b对*p取模的值。 输入格式 第一行输入整数a，第二行输入整数b，第三行输入整数p。 输出格式 输出一个整数，表示a * b mod p的值。 数据范围 1 ≤ a，b，p ≤ 10 18 输入样例： 3 4 5 输出样例： 2 实现代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;int main() &#123; ULL a, b, p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; ULL result = 0; while(b) &#123; if(b &amp; 1) &#123; result = (result + a) % p; &#125; a = (a &lt;&lt; 1) % p; b &gt;&gt;= 1; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;"},{"title":"ios 集成 OpenCV","date":"2019-08-15T02:17:16.000Z","path":"2019/08/15/ios-集成-OpenCV/","text":"IOS 集成 OpenCV 上OpenCV官网下载你所需要版本的opencv.framework库 将opencv.framework拖拉入项目文件夹。 在项目设置处，在General -&gt; Linked Frameworks and Libraries 导入下面这些库： 最后，将使用OpenCV的文件后缀从.m改为.mm"},{"title":"First","date":"2019-07-23T11:06:10.223Z","path":"2019/07/23/At-First/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New blog\" More info: Writing Run server1$ hexo server More info: Server or 1$ hexo s 有时候可能会遇到端口被占用，可列出端口4000的进程： 1$ netstat -ano|findstr 4000 然后关闭该进程（6972为进程ID）： 1$ taskkill /pid 6972 /f Generate static files1$ hexo generate More info: Generating or 1$ hexo g Deploy to remote sites1$ hexo deploy More info: Deployment or 1$ hexo d 此时若报如下错误： ERROR Deployer not found: git 可执行如下命令： 1npm install --save hexo-deployer-git"}]